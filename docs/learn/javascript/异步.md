 程序中将来执行的部分并不一定在现在运行的部分执行完成之后就立即执行.
 
 var data = ajax("http://some.url.1")

 console.log(data) 
 // data 通常不会包含ajax结果


 现在我们发出一个异步Ajax请求，然后在将来才能得到返回的结果。
 从现在到将来的等待，最简单的方法是使用一个通常称为回调函数的函数。
 ajax("http://some.url.1",function myCallbackFunction(data) {
  console.log(data) // 这里得到了一些数据
 })


 即它们都提供了一种机制来处理程序中多个块的执行，且执行每块时调用JavaScript引擎，这种机制被称为事件循环。
 换句话说，JavaScript引擎本身并没有事件的概念，只是一个按需执行JavaScript任意代码片段的环境。“事件”调度总是由包含它的环境进行。

 所以，举例来说，如果你的JavaScript程序中发出一个Ajax请求，从服务器获取一些数据，那你就在一个函数中设置好响应代码，然后JavaScript引擎会通知宿主环境：“嘿，现在我要暂停执行，你一旦完成网络请求，拿到了数据，就请调用这个函数。”

然后浏览器就会设置侦听来自网络的响应，拿到要给你的数据之后，就会把回调函数插入到事件循环，以此实现对这个回调的调度执行。

总结：事件调度机制是由JavaScript宿主环境提供的，JavaScript只需要告诉宿主环境，什么样的代码块，该在什么时候执行。


那么，什么是事件循环？

先通过一段伪代码了解一下这个概念：
// eventLoop是一个用作队列的数组
// （先进，先出）
var eventLoop = []
var event;

while(true) {
  // 一次tick
  if(eventLoop.length > 0 ) {
    // 拿到队列中的下一个事件
    event = eventLoop.shift()

    // 现在,执行下一个事件
    try {
      event()
    }
    catch(error) {
      reportError(err)
    }
  }
}

setTimeout(..)并没有把你的回调函数挂在事件循环队列中，它所做的是设定一个定时器，当定时器到时后，环境会把你的回调函数放在事件循环中。


进程和线程独立运行，并可能同时运行：在不同的处理器，甚至不同的计算机上，但多个线程能够共享单个进程的内存。
与之相对的是，事件循环把自身的工作分成一个个任务并顺序执行，不允许对共享内存的并行访问和修改。通过分立线程中彼此合作的事件循环，并行和顺序执行可以共存。

并行线程的交替执行和异步事件的交替调度，其粒度是完全不同的。


更常见的情况是，并发的进程需要相互交流，通过作用域或DOM间接交互。
正如前面介绍的，如果出现这样的交互，就需要对它们的交互进行协调以避免竟态的出现。

var res = []
function response(data) {
  res.push(data)
}

ajax("http://some.url.1", response)
ajax("http://some.url.2", response)
这里的并发“进程”是这两个用来处理Ajax响应的response调用。它们可能以任意顺序运行。



在ES6中，有一个新的概念建立在事件循环队列之上，叫作任务队列。
它是挂在事件循环队列的每个tick之后的一个队列。
[event1,event2,event3[job1、job2、job3],...]


小结
实际上，JavaScript程序总是至少分为两个块：第一块现在运行；下一块将来运行，
以响应某个事件。尽管程序是一块一块执行的，但是所有这些共享对程序作用域和状态的访问，所有对状态的修改都是在之前积累的修改之上进行的。

一旦有事件需要运行，事件循环就会运行，直到队列清空。事件循环的每一轮称为一个tick。用户交互、IO和定时器会向事件队列中加入事件。

任意时刻，一次只能从队列中处理一个事件。执行事件的时候，可能直接或间接地引发一个或多个后续事件。

并发是指两个或多个事件随时间发展交替执行，以至于从更高的层次来看，就像是同时在运行(尽管在任意时刻只处理一个事件)。

通常需要对这些并发执行的进程(有别于操作系统重的进程概念)进行某种形式的交互协调，比如需要确保执行顺序或者防止竟态的出现。这些进程也可以通过把自身分割为更小的块，以便其他进程插入进来。

