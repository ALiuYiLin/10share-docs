---
title: 事件循环机制
---
事件循环机制是JavaScript的一种运行机制，它可以让JavaScript代码在浏览器中异步执行。
---
# 事件循环机制（event loop）

## 三个重要概念

### 主线程

所有的同步任务都是在主线程里执行的，异步任务可能会在微任务（microtask）或者宏任务（macrotask）中

- 同步任务：指的是主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。
- 异步任务：指的是不进入主线程，当该任务可以执行了，才会进入主线程执行的任务。

### 微任务（microtask）

- promise
- async
- await
- process.nextTick(node)
- mutationObserver(html5新特性)

### 宏任务（macrotask）

- script整体代码
- setTimeout
- setInterval
- setImmediate
- I/O
- ui render

### 大致流程

简单的说，事件循环（event loop）是单线程的JavaScript在处理异步任务时进行的一种循环过程，具体来讲，对于异步事件它会先加入到事件队列中挂起，等主线程空闲时会去执行事件队列中的事件。

主线任务=》微任务=》宏任务 如果宏任务中还有微任务就继续执行宏任务中的微任务，如果宏任务中的微任务还有宏任务就在依次执行。

意思就是微任务先行

优先级：主线任务》微任务》宏任务



### 如何添加宏任务和微任务

1. 使用零延迟的setTimeout(fn) 宏任务添加
2. 使用queueMicrotask(fn)/Promise.resolve(fn) 微任务添加



### 事件循环机制的应用

#### 一、拆分CPU过载任务

假设我们有一个CPU过载任务

例如，语法高亮（用来给本页面中的示例代码着色）是相当耗费CPU资源的任务。为了高亮显示代码，它执行分析，创建很多着色的元素，然后将它们添加到文档中——对于文本量大的文档来说，需要耗费很长时间。

当引擎忙于语法高亮时，它就无法处理其他DOM相关的工作，例如处理用户事件等。它甚至可能会导致浏览器“中断”甚至挂起一段时间，这是不可接受的。

我们可以通过将大任务拆分成多个小任务来避免这个问题。高亮显示前100行，然后使用setTimeout来安排（schedule）后100行的高亮显示，依次类推。

为了演示这种方法，简单起见，让我们写一个从1数到10000000的函数，而不是写文本高亮。

如果你运行下面这段代码，你会看到引擎会挂起一段时间。对与服务端js来说这显而易见，并且如果你在浏览器中运行它，尝试点击页面上其他按钮时，你会发现在计数结束前不会处理其他事件。

```javascript
let i = 0

let start = Date.now()

function count() {
    // 做一个繁重的任务
    for(let j = 0; j < 1e9; j++ ) {
        i++
    }
    alert("Done in " + (Date.now() - start) + 'ms')
}
count()
```

浏览器甚至可能会显示一个脚本执行时间过长的警告

让我们来使用嵌套的setTimeout调度来拆封这个任务

```javascript
let i = 0
let start = Date.now()

function count() {
    do {
        i++
    } while( i % 1e6 != 0 )
    if(i == 1e9){
        alert("Done in " + (Date.now() - start) + 'ms')
    }else{
        setTimeout(count)
    }
}

count()
```

### 总结

1. 微任务队列优先于宏任务队列执行
2. 微任务队列上创建的宏任务会被添加到当前宏任务队列的尾端  
3. 微任务队列中创建的微任务会被添加到微任务队列的尾端



JavaScript是单线程的，为了协调各种任务，就有了事件循环机制。它有一个调用栈，函数调用就放进去，执行完就弹出。还有一个任务队列，里面是各种待处理的任务。主线程执行完调用栈的代码后，就从任务队列中取出任务到调用栈执行。异步任务比如网络请求、定时器，完成后会进入任务队列。这么循环处理，保证了程序有序运行。