---
excerpt: typeof操作符返回一个字符串，表示未经计算的操作数的类型。
---
# == 和 === 区别

## 一、等于操作符 ==

等于操作符（==）在比较中先会进行类型转换，再确定操作数是否相等。

### 小结

- 两个都为简单类型，字符串和布尔值都会转换为数值，再比较。
- 简单类型与引用类型比较，对象转化其原始类型的值，再比较。
- 两个都为引用类型，则比较它们是否指向同一个对象。
- null和undefined相等
- 存在NaN则返回false

## 二、全等操作符

全等操作符由3个等于符号（===）表示，只有两个操作数在不转换的前提下相当才返回true。即类型相同，值也需相同。

### 区别

相等操作符会做类型转换，再进行值的比较，全等操作符不会做类型转换。



# typeof 与 instanceof 区别

## 一、typeof

typeof操作符返回一个字符串，表示未经计算的操作数的类型。

### 例子

```JavaScript
typeof 1 // 'number'
typeof '1' // 'string'
typeof undefined // 'undefined'
typeof true // 'boolean'
typeof Symbol() // 'symbol'
typeof null // 'object'
typeof [] // 'object'
typeof {} // 'object'
typeof console // 'object'
typeof console.log // 'function'
```

## 二、instanceof

instanceof运算符用于检查构造函数的prototype属性是否出现在某个实例对象的原型链上

使用如下：

```javascript
object instanceof constructor
```

object为实例对象，constuctor为构造函数

构造函数通过new可以实例对象，instanceof能判断这个对象是否是之前那个构造函数生成的对象。

```javascript
// 定义构造函数
let Car = function(){}
let benz = new Car()
benz instanceof Car // true
let car = new String('xxx')
car instanceof String // true
let str = 'xxx'
str instanceof String // false
```

关于instanceof的实现原理，可以参考下面：

```javascript
function myInstanceof(left, right) {
    // 这里先用typeof来判断基础数据类型，如果是，直接返回false
    if(typeof left !== 'object' || left === null) return false
    
    // getProtypeof 是Object对象自带的API，能够拿到实例的原型对象
    left proto = Object.getPrototypeOf(left)
    while(true) {
        if(proto === null) return false
        if(proto === right.prototype) return true // 找到相同原型对象，返回true
        proto = Object.getPrototypeOf(proto)
    }
}
```

也就是顺着原型链去找，直到找到相同的原型对象，返回true，否则返回false

## 三、区别

typeof 与 instanceof 都是判断数据类型的方法，区别如下：

- typeof 会返回一个变量的基本类型，instanceof返回的是一个布尔值。
- instanceof可以准确判断复杂引用数据类型，但是不能正确判断基础数据类型。
- 而typeof也存在弊端，它虽然可以判断基础数据类型（null除外），但是引用数据类型中，除了function类型以外，其他的也无法判断。

可以看到，上述两种方法都有弊端，并不能满足所有场景的需求。

如果需要通用检测数据类型，可以采用Object.prototype.toString,调用该方法，统一返回格式[object, xxx] 的字符串

如下：

```javascript
Object.prototype.toString({}) // '[object Object]'
Object.prototype.toString.call(1) // '[object Number]'
Object.prototype.toString.call('1') // '[object String]'
Object.prototype.toString.call(/123/g) // '[object RegExp]'
```

了解了toString的基本用法，下面就实现一个全局通用的数据类型判断方法。

```javascript
function getType(obj) {
    let type = typeof obj
    if(type !== 'object') {
        return type
    }
    return Object.prototype.toString.call(obj).replace(/^\[object (\S+)\]$/,'$1')
}
```

使用如下

```javascript
getType([]) // 'Array'
getType('123') // 'string'
getType(window) // 'Window'
```



