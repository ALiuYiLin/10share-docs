---
title: 渲染机制
---
vue是如何将一份模板转换为真实的DOM节点的，又是如何高效地更新这些节点的呢？我们接下来就将尝试通过深入研究vue的内部渲染机制来解释这些问题。
## 虚拟DOM
你可能已经听说过“虚拟DOM”的概念了，Vue的渲染机制正是基于这个概念构建的。
虚拟DOM（Virtual DOM，简称VDOM）是一种编程概念，意为将目标所需要的UI通过数据结构“虚拟”地表示出来，保存在内存中，然后将真实的DOM与之保持同步。这个概念是由React率先开拓，随后被不同的框架采用，当然也包括vue。
与其说虚拟DOM是一种具体的技术，不如说是一种模式，所以并没有一个标准的实现。我们可以用一个简单的例子来说明。
```javascript
const vnode = {
  type: 'div',
  props: {
    id: 'hello'
  },
  children: [
    /* 更多 vnode */
  ]
}
```
这里所说的vnode即一个纯javascript对象（一个虚拟节点），它代表着一个div元素。它包含我们创建实际元素所需的所有信息。它还包含更多的子节点，这使它成为虚拟DOM树的根结点。

一个运行时的渲染器将会遍历整个虚拟DOM树，并据此构建真实的DOM树。这个过程被称之为挂载（mount）。
如果我们有两份虚拟DOM树，渲染器将会有比较地遍历它们，找出它们之间的区别，并应用这其中的变化到真实DOM上。这个过程被称之为更新（patch），有被称之为比对（diffing）或者协调（reconciliation）。

虚拟DOM带来的主要收益是它让开发者能够灵活、声明式地创建、检查和组合UI所需的结构，同时只需把具体的DOM操作留给渲染器去处理。

## 渲染管线
从高层的视角看，vue组件挂载时会发生如下几件事：
1. 编译：Vue模版被编译为渲染函数：即用来返回虚拟DOM树的函数。这一步骤可以通过构建提前完成，也可以通过使用运行时编译器即时完成。

2. 挂载：运行时渲染器调用渲染函数，遍历返回虚拟DOM树，并基于它创建实际的DOM节点。这一步会作为响应式副作用执行，因此它会追踪其中所用到的所有响应式依赖。

3. 更新：当一个依赖发生变化后，副总用会重新运行，这时候会创建一个更新后的DOM树。运行时渲染器遍历这颗新树，将它与旧树进行比较，然后将必要的更新应用到真实DOM上去。

## 模版vs.渲染函数
vue模版会被编译成虚拟DOM渲染函数。Vue也提供了API使我们可以不使用模版编译，直接手写渲染函数。在处理高度动态的逻辑时，渲染函数相比于模版更加灵活，因为你可以完全地使用JavaScript来构造你想要的vnode。

那为什么vue默认推荐使用模版呢？有以下几点原因：
1. 模版更贴近实际的HTML。这使得我们能够更方便地重用一些已有的HTML代码片段，能够带来更好的可访问性体验、能更方便地使用CSS应用样式，并且更容易使设计师理解和修改。
2. 由于其确定性的语法，更容易对模版做静态分析。这使得Vue的模版编译器能够应用许多编译时优化来提升虚拟DOM的性能表现。

在实际中，模版对大多数的应用场景都是够用且高效的。渲染函数一般只会在需要处理高度动态渲染逻辑的可重用组件中使用。


## 带编译时信息的虚拟DOM
虚拟DOM在React和大多数其他实现中都是存运行时的：更新算法无法预知新的虚拟DOM树会是怎样，因为它总是需要遍历整颗树、比较每个vnode上props的区别来确保正确性。另外，即使一颗树的某个部分从未改变，还是会在每次重新渲染时创建新的vnode，带来了大量不必要的内存压力。这也是虚拟DOM最受诟病的地方之一：这种有点暴力的更新过程通过牺牲效率来换取声明式的写法和最终的正确性。

但实际上我们并不需要这样。在Vue中，框架同时控制着编译器和运行时。这使得我们可以为紧密耦合的模版渲染器应用许多编译时优化。编译器可以静态分析模版并在生成的代码中留下标记，使得运行时尽可能走捷径。与此同时，我们仍旧保留了边界情况时用户想要使用底层渲染函数的能力。我们称这种混合解决方案为带编译时信息的虚拟DOM。